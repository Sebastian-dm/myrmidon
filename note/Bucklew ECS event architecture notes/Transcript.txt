I am Brian bucko I'm one of the co-founders of Freehold games my talk is largely going to be about what happens when you try to make a rogue like and you're not as smart as the two guys who have presented already this is this is as philosophical as I'm going to get which is maybe stories are just data with a soul and so I'm largely going to talk about the data side of that Jason who is the other half of freehold games will talk about the soul part so you'll get a nice solo speech for me so we just released Sproggiwood on the App Store two days ago so my slides are a little rough uh it's going well we've previously released a game called Caves of Qud but I have been doing roguelike development for a long time though you've never heard of me because it took me a very long time to actually release anything so this was an article that I wrote many years ago sitting on usenet in a cyber cafe in like 1998 for Darren Heon's roguelike news which maybe some very old people remember but uh and it was about creating a map and so I put in my very terrible code which will horrify anybody who is smart about how to write your code right and the most embarrassing thing about this article is that this algorithm is still absolutely in use in Sproggiwood I still have this code that's been ported in the first couple dungeons are still generated by this algorithm and uh so is the first dungeon in Caves of Qud and you get to the end of the article and I was like oh well maybe I'll sign this for posterity and I'll be important one day right like so we got Brian buckler I was 18 at the time and I was working on a project called dungeon or this game needs a new name and the name of that game was eventually Caves of Qud and you can see that I had a very optimistic release date of early 1998 and right and the game did not release until 2008 or so this is about this sort of data driven design and cut the engines of cut and Sproggiwood because Sproggiwood is largely an evolution of the Qud design or why did dungeon come out in 10 years late in three acts and so act one is it is Pitch Black and you are likely to be eaten by a grw and this is how I felt at the time right so I'm like 18 and I've dropped out of high school and I've dropped out of college and I'm sort of making my way and people this is a very dark time in the world where you don't have the internet to go and figure things out and so you've maybe gone to a college library and read like gone through the card catalogs and find books about how you're how you how you do RC casting or make programming programs work and so you get a lot of people at the time that are saying hey object oriented design is great why don't you make a class hierarchy and this is how you should do it right so you know you've got vehicles and from those you drive wheeled vehicles and you're like okay well I think this this isn't too hard right I'm going to start with a weapon and it's going to hit things and I'm going to get an elemental weapon that deals damage and this this this the second one should not say Elemental weapon it should say ice sword this was a tragedy of the Sproggiwood release but you oh great I'm a genius right so now I can go in and I can go weapon. deal damage to whatever it is and one of them is dealing fire damage one of them is dealing ice damage and it's wonderful right and you build your game and you got a little guy walking around and dealing ice damage and fire damage and you go one day hey what if I want to like a fire ice sword and suddenly things don't look so good right like and this would happen more than once or you would collapse the data to say okay well let's get rid of this maybe I'm not so smart anymore and we're just going to make an elemental weapon with some flags that are Fire and Ice and that works and let's keep going and So eventually surely this time I have it and so at this point it's like 2000 2002 I built a roguelike to the point where I can play it and then I try to add some stuff to it and it just doesn't work and I feel really bad about myself and it you know I'll go like oh an openable wall that creates one of these horrifying diamonds and a creature chest which is a mimic that doesn't work either now I've got to collapse those and oh a weapon armor that doesn't work either and this is so this is how I felt for the first four or five years of trying to write a rogue like that I just didn't hate working on and so a few papers were coming out at this time and I mean I was still a very young engineer that didn't know what I was doing but I thought that these papers were interesting and some were particularly good and I've got a bibliography at the end for anybody who wants to go out and read them but there were a couple really influential ones about the systems a guy named Scott bis wrote about Dungeon Siege right he talked about how he built not only component-based designs but these really cool like C++ scripting tools and at the end of these he said something that sort of caught my imagination which was hey I wrote this in C++ but had I had .NET at the time I would have probably used reflection and I had no idea what reflection was at the time like I was like what's reflection but Scott Biles says it's cool so that's interesting and so I sat down I so that was I had had I had this stuff in my mind but I didn't know how it applied to Rogue likes and one day I said well this is just not working these class designs what's wrong and I started to do what later in my life I would realize was requirements analysis right so the IEEE says it's a condition or capability needed by a user to solve a problem or achieve an objective IEEE requirements what problem really am I trying to solve because I think it's an important question to ask yourself because it's very easy to solve the wrong problem because it's fun or to solve the wrong problem because you don't realize that you're solving somebody has come to you with a solution right very often when you do real world engineering people will come to you with a solution it's very important to ask well before we implement the solution what is the problem actually that we're trying to solve and so I did not I do not intend to say that I did this mindfully I accidentally asked myself these questions one weekend in a fit of frustration but it turned out to be the right thing that I eventually canonized into part of a process and I said well what really am I trying to build here I wanted to build not a good piece of code which you'll see later right and nothing I'm doing here is a good piece of code what I wanted to build was a big emergent CN box of a world I had been playing games like Rogue on my 8086 in games like Omega and alpam man right these games which I thought were awesome but I would look at them and go like man you could take this one step farther right you could have really isometric feeling objects where I could go in with a games would start to do this I could pick up a tree and hit it hit anything with a tree right but those are very hard-coded sort of instances and the thing that I felt was really interesting were these credible feeling isomorphic worlds right and I wanted to be able to think of some new interaction right and add it to the code without the code increasing in complexity exponentially I wanted to be able to say hey I have an idea and I want to implement it and I want it to have a linear relationship with the complexity of the code so that maybe the first thing that I write a fire sword is a little more difficult so maybe it takes five units of effort but the four thousandth thing I add to this code because this is a in in the kind of roguelike that I'm making not these very elegant Little Things these big sprawling games I wanted to make sure that the 4,000th thing I added took also five units of effort right and that meant largely that I was trying to remove the code as a barrier to game inspiration I wanted to just get it out of the way so it's something that's there it has to work has to work well enough to play the game but the I figured out that the most important thing to me was to get that code out of the way of just thinking up of an idea and putting it in the game and that largely meant decoupling technically right when you start to collapse class hierarchies you start to couple these ideas so that if you've got a big old list of is fire damage is ice damage am I invulnerable right each one of those even if only a tiny bit starts to couple to the next thing you add and so the next thing you add gets a little more complicated and a little more complicated so even if all you're doing is adding a new Elemental type you have to remember all of the places that this that no about that that damage type and eventually you get to the point where the Cod just collapses like I showed it in in before and so I started thinking about the ideas that were floating around the time in terms of component-based architecture and so this says that instead of a hierarchy of things everything in the roguelike could be just an empty object so an object with nothing in it does nothing right well that's a nice little bit of parsimony that's probably good behavior right and so you can inject into the object a list of individual components that know about their own thing so uh a composite object that has a physics behavior and has a render behavior and has maybe a weapon behavior that makes it a little more specialized than an object with just a physics and render Behavior I said oh this is a pretty good idea and I didn't think about this so much as just try it because my coding technique is not to very carefully think about things but just try everything that doesn't work right and so I started saying well how are these things going to talk to one another right so if I've got this object and I got these components it wasn't really well specified in some of the discussions how that these components were supposed to interact nowadays this is actually a pretty common pattern and there are some really good papers on it but I was sort of just like again in 2002 internet is not very well developed you're on like somebody's Geocities page or Usenet going like I like component architecture right and getting pictures of their children or whatever and so in my professional work I had worked I was doing 132 programming so if anybody's written Windows programming the way they talk are events and I was like events seem like a pretty good thing to do here because it allows Windows to talk to one another controls to talk to one another without deep coupling right I can send an event that says draw to anything in a Windows system and it can take a very domain specific behavior and so I started building the system and this was still in C++ at this time I was building something I was like oh fubby is so cool if you go read Scott Bilasâ€™ fubby that it would bind automatically to .dlls and so I got this partially working in C++ and this is around 2003 or 2004 and I said well here's how it's going to work an event will come into an object and it will just go through these components in order and these objects can during this processing just fire events to other game objects so won't talk to components that they eventually did just for optimization but conceptually all they do is these events talk to other components so a physics Behavior a render Behavior a weapon Behavior doesn't know anything about the other kinds of behaviors all they can do is fire these isomorphic events that all these components can see and so I started building some practical Solutions one of the first things you want to do is you want to make a little Cobalt run around and kill it with your sword right and so I said well probably everything in my world is destructible because that's a fun world so physics has 10 hit points and physics will understand a take damage event and subtract the amount in there by 10 now there's a little bit of coupling here that there that every the things know about take damage but I'm actually just using string events there's not even in Caves of Qud today like a big table of actual vent IDs or anything it's literally just a string that switches inside the component on the string and so suddenly you've got this take damage you could have a second object that wants to have a very specialized uh damage like say I'm a mouse and I have very specialized body parts that can be damaged it could respond to take damage in a very different way by just having a different instance of the physics opponent but I hadn't gotten that far yet I was just like is this going to work or is this going to collapse like a horrible class hierarchy problems I've had for the last six years of my life I said well one of the things you want to do is be invulnerable so how would you do that in a component based system well let's create an invulnerability component it will be the first thing in the Handler list and if it sees it takes damage it will assign the amount to zero then physics will get that event which has been modified by the invulnerability and takes no damage well that's cool and not only that but the physics doesn't know anything about invulnerability physics has not changed all physics knows about is hit points what about Elemental types well let's add a new type equals fire and these are just name value pairs so there's no definition I've just added literally type and fire in here and now I can add a fire Shield component that says hey if the type is equal to fire set the amount to zero and physics still doesn't know anything about invulnerability it doesn't know anything about Elemental damage types it doesn't know anything about shielding right I have injected Elemental damage types here with no coupling and I said this is working pretty well so what if you wanted to pick up any object in the world and hit something with it which is something you often want to right in Real Worlds as well as virtual ones and so I said okay well what's going to happen is the physics Behavior will get an event from whatever is running the system Let's ignore that for right it's physics on that side too but physics says okay well you've been hit you're hitting something the you've been a melee attch hit your target is X you do whatever you want if you want to do nothing that's fine it's your feather and so the base implementation is maybe take damage and amount relative to the weight which might be a property on physics and the type is bludgeoning and so well now I can pick up anything in the world and hit you with it but what if a sword does something different well and so here's the code right so this is the actual code for so we create a new event I send this event to myself that I'm dealing melee damage I can modify the amount of damage this lets me then plug in a weapon Behavior so the melee attack hit comes in the physics Behavior says hey if there's any components here that want to specialize damage I'm going to fire a dealing damage melee event you listen for it and you can modify the event and I'll do that before I send out the take damage so physics sends a dealing melee damage event a weapon Behavior now how is a type and a damage it modifies it and out to the Target object goes take damage one to six again physics doesn't know anything about being a weapon right all it's done is added a new kind of event that you can hook into and now I can go crazy right I can go oh weapon behavior is slashing what about that fiery type that collaps you know fiery type okay that's cool fiery will come after it says oh well I'm a fire sword I'm going to add fire to the type of damage I'm dealing and stick add another 1d6 to the damage parameter before it goes out and here's the fiery ice sword Behavior right so now here's the implementation of a complete uh non-connected fire ice sword that completely collapsed the previous hierarchy but is now divided into four components a physics Behavior which is orchestrating this Behavior right a weapon Behavior which is dealing some base damage and a fiery and Ice Behavior which are adding Elemental damage and it's completely decoupled and this this really worked I kept adding stuff to this until I had Caves of Qud essentially so that was many years and so I realized at some point in the C++ implementation that the biggest problem with this system is now what is a kind of object if I want to make if I wanted to make a new kind of object in a class hierarchy I would derive it and now I can create instances of it right a Cobalt is a kind of monster I can create a new cobalt but here all I have is a bag of components that have names and an object is just a list of these objects so a frostburn sword is a physics Behavior plus a weapons Behavior plus a fire Behavior plus an IC behavior and here's data right I said I need some way to define a blueprint like what is a frostburn sword a game object can have any combination of components and each component can have its own parameters that change the way it behaves so that uh you may have an armor component and a little armor you got leather armor and has a AC of three may have plate armor with an AC of six that's just a variable on the armor component itself so I need a way to define these and this is when I the light bulb goes off on my head and this is like eight years of working on this right like oh this is what Scott was talking about when he said reflection I see now right because the blueprints look like this when you start to put it in data here's a physical object it has a physics part and a render part give it some defaults a sword inherits physical object and what that means is it just it's this just saves me typing when this inherits a physical object all it says is I'm going to take all the component definitions and pretend they're at the top of this list and a fire sword is the same a sword that adds a new component fiery this is working pretty well how are we going to make this string together and so this is the whole engine of caves of cut in Sproggiwood this is there you end up for efficiency reasons doing things like letting components talk to one another directly not just via events because practically you're rendering things at a certain frame rate right but conceptually this is all that's going on here you have events each event has a ID and uh bag of parameters name value pairs you've got a component definition its only interfaces fire event it takes an event class that you've defined you've got a game object which is just an ordered list of components and fire event and that's how you get an event to an individual component you're not ever using the component fire event you are calling it on game object and it fires it on each of its internal components in order and then to create these you have some Factory which loads These Blueprints and allows you to pass in a blueprint name and return you a game object and that is the whole thing and so I started to put this stuff together in game and so let's see how it works in practice so here is the actual C code this is the this is the reflection that Scott bis was talking about so if you haven't worked in a language like C and Java at the time it was all new nowadays this is what all the kids do right everything is duct typed Dynamic stuff but this was cool when I got into it right so I go through all the blueprints and so for each part blueprint so that's each component list my nomenclature is a little different in the actual code I look in a namespace xl. world. parts with the name of that blueprint so I look for a class called xl. parts. weapon and if that's defined mind I Dynamic dynamically create an instance of it I go through each field of it and if it has a public member named damage I have a big piece of code that says okay well if damage is an in I'm going to try to convert it to an ENT or if it's a string I'm going to just paste in this damage if it's a string but allows me to dynamically create these parts so to create a new component all I have to do is create a new class as public members and that's it I can now create it with my factory so here are some practical examples of some of the first things we did in caves of cut so I've got a water container and the important part is up there at the top so you got a liquid volume so this is a component that knows how to make this object contain fluid of all kinds and CES of cut has like just this ridiculously overelaborate fluid simulation system and so you've got a canteen so a canteen says it's a canteen it changes its description to an aluminum jug and it inherits from water container so it gets all these default properties and so encode one of the things it does so here's the actual implementation of Fire EV so all the real programmers will be horrified because this is how my code works right so fire event takes an event it says hey is the ID get display name and down at the end it just depins git liquid description to the end and so at the bottom you can see the result of this so the default implementation of get display name starts with just the name of the object so in this case it's water skin and then it sticks the liquid description at the end which is empty or 32 dram of fresh water cool I was like this is working pretty good then we said well what one of the first cool items we added to Caves of Qud was a recycling suit which was like a dune still suit right so you're walking around and in Qud water is your currency and you're collecting water in this still suit and I said well that means this armor is really a water container right and so what I did is I literally just inherited from armor up there and I added the liquid volume about halfway through and at the bottom you can see the result you've got a suit of armor that has eight Dam a fresh water in it and you can click it and it gives you the menu to empty it out or fill it up and then you can see at the bottom I've got a little new component called recycling suit filler which does the own and again liquid component knows nothing about being filled up right this recycling suit filler uh watches for the begin turn event and every so many turns it'll it says oh do I have a liquid component if so add you know fire and add water event and that is it so some interesting some interesting notes are that caves of cutting has 1,400 individual components so if you could imagine trying to build a class hierarchy with your brain right I can barely build one with 12 instances and so if I was try to sit down there and map out what a class hierarchy with 14400 little individual boxes looks like I would just never be able to succeed and so the component architecture scaled really well for me the other interesting note is that when I picked up Unity 3D I realized that it's its engine looked almost identical to this right and I didn't copy this I just developed it at the same time in the same kind of environment using the same kind of sources and so you got parallel evolution of two very similar component systems and so what I'm describing here is not unique to caves of cut anymore right I certainly do not propose that I invented it but I you know I invented at the same time from the same sources and it's an architecture that works really well in a lot of production games and so if you're not a smart person like me right if you're dumb like me this system works really well to allow your small brain to chunk it up and write functionality without having to you know overheat thinking too hard and so that is it thank [Applause] you any questions so the question is how do I edit those 1400 components and the answer is yes it's notepad and Jason hates that right so Jason a lot of the design I'm like hey look I wrote the system I put in 200 example objects have fun and he's like these aren't even in alphabetical order and right they're just the order that I decided to implement them in and so you can't actually like Unity is a really nice front end to exactly this kind of system they've built a gooey front end there's plenty of commercial game engines that have a I mean when you look at the data so we can we can drop back to the data here right this data is really well structured it is it is not rocket science to build a GUI editor for this kind of thing because it's literally named value Pairs and a list of strength tied to a list of strengths right so like if you feel like engineering something you could definitely do that I'm just super lazy and so I'm like you've got notepad and it's fine oh well yeah Jeff said that that uh yeah duh right the small talk programmers of the world and plenty of programmers of the world this is obvious stuff that's been around for 100 years right and this is not new stuff I'm just trying to expose it to the people who've gone to like CS 101 and had a college professor that doesn't know what they're talking about and tried to tell you to make a class hierarchy and it's not working it's because it's not a good idea there yeah and so I you know I wanted to if you're building a rogue like and failing people tend to take on roguelikes as a first programming project for some reason and it's one of the absolute hardest things you can possibly do so if you're trying this and failing it is okay because it is it is seriously hard and if you're thinking like wow I never I never really asked myself what problem I was trying to solve and came up with an answer that's okay too because that's the key that's the key challenge of engineering and the best Engineers I know still are improving day-to-day at asking at learning to ask themselves am I solving the right problem right learning to ask yourselves am I solving the right problem in the right way is something you're going to improve on your whole career and never really be particularly good at because your simian brain is just not well equipped to deal with those kind of problems right at best you're hacking it to be able to come up with any kind of solution to those problems at all okay so the question is uh in my in my talk I showed the events coming in in a priority order right so that one component could capture an event and respond to it before a second component got it and the answer is in caves of cut in this code that you're seeing it didn't right that was a problem I realized earlier and so I solved that in Caves of Qud by having really inefficient chains of events begin attack right attacking after attack really after attack is done right and so you forced an a hierarchical order like that in newer revisions of this engine and in unity what they the typical solution is in your part to have a priority which has some default like 100 and if you assign a higher priority you just keep those components in a priority cue instead of a list and when you insert a you just insert it in the priority order and that allows you to control the event flow Sproggiwood still doesn't I don't I haven't found it really to be that useful because a chain of events just works and it's really controllable and I don't have to worry about getting the priority right for other projects that might not be appropriate it's not too hard to add right because the only differences in that in that architecture slide instead of a list that's a priority CU and you're assigning that priority somewhere.